[package]
name = "DESIGNFUSION"
version = "0.0.0"
description = "A Tauri App"
authors = ["you"]
license = ""
repository = ""
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[build-dependencies]
tauri-build = { version = "1.2", features = [] }

[dependencies]
anyhow = "1.0.66"
serde_json = "1.0"
regex = "1.7.0"
log = "0.4.17"
winit = "0.27"
url = "2.5.0"
windows = "0.36"
image = "0.23"
serde_urlencoded = "0.7.1"
reqwest = "0.11.13"
serde = { version = "1.0", features = ["derive"] }
tauri = { version = "1.2", features = ["reqwest-client", "api-all", "cli", "system-tray", "devtools", "windows7-compat"] }
libloading = "0.7"
opener = "0.7.0"
tauri-plugin-deep-link = "0.1.1"
tauri-plugin-localhost = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
window-shadows = "0.2.1"
tauri-plugin-single-instance = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
tauri-plugin-fs-extra = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }

[features]
# by default Tauri runs in production mode
# when `tauri dev` runs it is executed with `cargo run --no-default-features` if `devPath` is an URL
default = ["custom-protocol"]
# this feature is used used for production builds where `devPath` points to the filesystem
# DO NOT remove this
custom-protocol = ["tauri/custom-protocol"]




use anyhow::Result;
use log::info;
use regex::Regex;
use tauri::Runtime;
// use serde_json::Value;
use std::{
    // collections::HashMap,
    fs::{ self, File },
    path::{ Path, PathBuf },
    process::Command,
};
// use tauri::updater::UpdateResponse;
use tauri::{ utils::config::Config, CustomMenuItem, Menu, MenuItem, Submenu, Window };
// AppHandle, Manager, Wry
use tauri::Manager;
use tauri::{ command };

use window_shadows::set_shadow;
use opener;




#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// use tauri::{CustomMenuItem, Menu, MenuItem, Submenu, Window};
use windows::{
    core::Result,
    Win32::System::Com::{CoInitializeEx, CoUninitialize, COINIT_MULTITHREADED},
    Win32::UI::Shell::{SHCreateItemFromParsingName, IShellItem, IShellItemImageFactory, SIIGBF_RESIZETOFIT},
    Win32::Graphics::Gdi::{CreateCompatibleDC, DeleteDC, DeleteObject, SelectObject, BITMAPINFO, BITMAPINFOHEADER, BI_RGB, DIB_RGB_COLORS},
    Win32::System::Memory::GlobalFree,
};
use image::{DynamicImage, GenericImageView, ImageBuffer, Rgba};
use std::path::Path;

fn get_thumbnail(file_path: &str, thumbnail_size: u32) -> Result<DynamicImage> {
    unsafe {
        CoInitializeEx(std::ptr::null_mut(), COINIT_MULTITHREADED)?;

        let shell_item: IShellItem = SHCreateItemFromParsingName(file_path, None)?;

        let image_factory: IShellItemImageFactory = shell_item.cast()?;
        
        let hbitmap = image_factory.GetImage(
            &windows::Win32::Foundation::SIZE {
                cx: thumbnail_size as i32,
                cy: thumbnail_size as i32,
            },
            SIIGBF_RESIZETOFIT,
        )?;

        let mut bitmap_info = BITMAPINFO {
            bmiHeader: BITMAPINFOHEADER {
                biSize: std::mem::size_of::<BITMAPINFOHEADER>() as u32,
                biWidth: thumbnail_size as i32,
                biHeight: -thumbnail_size as i32,
                biPlanes: 1,
                biBitCount: 32,
                biCompression: BI_RGB as u32,
                biSizeImage: 0,
                biXPelsPerMeter: 0,
                biYPelsPerMeter: 0,
                biClrUsed: 0,
                biClrImportant: 0,
            },
            bmiColors: [Default::default(); 1],
        };

        let hdc = CreateCompatibleDC(None);
        let mut bits = std::ptr::null_mut();
        let dib = windows::Win32::Graphics::Gdi::CreateDIBSection(
            hdc,
            &bitmap_info,
            DIB_RGB_COLORS,
            &mut bits,
            None,
            0,
        );

        SelectObject(hdc, dib);
        windows::Win32::Graphics::Gdi::BitBlt(
            hdc,
            0,
            0,
            thumbnail_size as i32,
            thumbnail_size as i32,
            hdc,
            0,
            0,
            windows::Win32::Graphics::Gdi::SRCCOPY,
        );

        let slice = std::slice::from_raw_parts(bits as *const u8, (thumbnail_size * thumbnail_size * 4) as usize);
        let image = ImageBuffer::<Rgba<u8>, _>::from_raw(thumbnail_size, thumbnail_size, slice.to_vec())
            .ok_or_else(|| windows::core::Error::from(windows::core::HRESULT(1)))?;

        DeleteObject(dib);
        DeleteDC(hdc);
        GlobalFree(hbitmap.0);

        CoUninitialize();
        Ok(DynamicImage::ImageRgba8(image))
    }
}

#[command]
fn get_thumbnail_command(file_path: String) -> Result<String, String> {
    let thumbnail_size = 128;
    let output_path = format!("{}.png", file_path);

    match get_thumbnail(&file_path, thumbnail_size) {
        Ok(thumbnail) => {
            thumbnail.save(&output_path).map_err(|e| e.to_string())?;
            Ok(output_path)
        }
        Err(e) => Err(e.to_string()),
    }
}


#[command]
pub fn open_designer(path: &str){
    opener::open(path).map_err(|e| format!("Failed to open path: {}", e));
}

#[command]
pub fn reveal_file(path: &str){
    // opener::reveal(path).map_err(|e| format!("Failed to reveal path: {}", e));
}

pub fn set_window_shadow<R: Runtime>(app: &tauri::App<R>) {
    let window = app.get_window("Login").unwrap();
    set_shadow(&window, true).expect("Unsupported platform!");
}

#[command]
pub fn chat_root() -> PathBuf {
    tauri::api::path::home_dir().unwrap().join(".onChain")
}

#[command]
pub fn set_window_home_shadow(handle: tauri::AppHandle) {
    let window = handle.get_window("Home").unwrap();
    set_shadow(&window, true).expect("Unsupported platform!");
}


#[command]
pub fn init() -> bool {
    let conf_file = chat_root().join("onChain.conf.json");
    if !exists(&conf_file) {
        create_file(&conf_file).unwrap();
    }
    return exists(&conf_file);
}

#[command]
pub fn get_tauri_conf() -> Option<Config> {
    let config_file = include_str!("../../tauri.conf.json");
    let config: Config = serde_json
        ::from_str(config_file)
        .expect("failed to parse tauri.conf.json");
    Some(config)
}

#[command]
pub fn exists(path: &Path) -> bool {
    Path::new(path).exists()
}

#[command]
pub fn create_file(path: &Path) -> Result<File> {
    if let Some(p) = path.parent() {
        fs::create_dir_all(p)?;
    }
    File::create(path).map_err(Into::into)
}

// #[command]
// pub fn user_script() -> String {
//     let user_script_content = fs::read_to_string(script_path()).unwrap_or_else(|_| "".to_string());
//     format!(
//         "window.addEventListener('DOMContentLoaded', function() {{\n{}\n}})",
//         user_script_content
//     )
// }

#[command]
pub fn open_file(path: PathBuf) {
    info!("open_file: {}", path.to_string_lossy());
    #[cfg(target_os = "macos")]
    Command::new("open").arg("-R").arg(path).spawn().unwrap();

    #[cfg(target_os = "windows")]
    Command::new("explorer").arg("/select,").arg(path).spawn().unwrap();

    // https://askubuntu.com/a/31071
    #[cfg(target_os = "linux")]
    Command::new("xdg-open").arg(path).spawn().unwrap();
}

// #[command]
// pub fn clear_conf(app: &tauri::AppHandle) {
//     let root = chat_root();
//     let app2 = app.clone();
//     let msg = format!("Path: {}\nAre you sure to clear all onChain configurations? Please backup in advance if necessary!", root.to_string_lossy());
//     tauri::api::dialog::ask(
//         app.get_window("core").as_ref(),
//         "Clear Config",
//         msg,
//         move |is_ok| {
//             if is_ok {
//                 fs::remove_dir_all(root).unwrap();
//                 tauri::api::process::restart(&app2.env());
//             }
//         },
//     );
// }

// #[command]
// pub fn merge(v: &Value, fields: &HashMap<String, Value>) -> Value {
//     match v {
//         Value::Object(m) => {
//             let mut m = m.clone();
//             for (k, v) in fields {
//                 m.insert(k.clone(), v.clone());
//             }
//             Value::Object(m)
//         }
//         v => v.clone(),
//     }
// }

#[command]
pub fn gen_cmd(name: String) -> String {
    let re = Regex::new(r"[^a-zA-Z0-9]").unwrap();
    re.replace_all(&name, "_").to_lowercase()
}

// #[command]
// pub async fn get_data(
//     url: &str,
//     app: Option<&tauri::AppHandle>,
// ) -> Result<Option<String>, reqwest::Error> {
//     let res = reqwest::get(url).await?;
//     let is_ok = res.status() == 200;
//     let body = res.text().await?;

//     if is_ok {
//         Ok(Some(body))
//     } else {
//         info!("onChain_http_error: {}", body);
//         if let Some(v) = app {
//             tauri::api::dialog::message(v.get_window("core").as_ref(), "onChain HTTP", body);
//         }
//         Ok(None)
//     }
// }

// #[command]
// pub fn run_check_update(app: AppHandle<Wry>, silent: bool, has_msg: Option<bool>) {
//     info!("run_check_update: silent={} has_msg={:?}", silent, has_msg);
//     tauri::async_runtime::spawn(async move {
//         let result = app.updater().check().await;
//         let update_resp = result.unwrap();
//         if update_resp.is_update_available() {
//             if silent {
//                 tauri::async_runtime::spawn(async move {
//                     silent_install(app, update_resp).await.unwrap();
//                 });
//             } else {
//                 tauri::async_runtime::spawn(async move {
//                     prompt_for_install(app, update_resp).await.unwrap();
//                 });
//             }
//         } else if let Some(v) = has_msg {
//             if v {
//                 tauri::api::dialog::message(
//                     app.app_handle().get_window("core").as_ref(),
//                     "onChain",
//                     "Your onChain is up to date",
//                 );
//             }
//         }
//     });
// }

// Copy private api in tauri/updater/mod.rs. TODO: refactor to public api
// Prompt a dialog asking if the user want to install the new version
// Maybe we should add an option to customize it in future versions.
// #[command]
// pub async fn prompt_for_install(app: AppHandle<Wry>, update: UpdateResponse<Wry>) -> Result<()> {
//     info!("prompt_for_install");
//     let windows = app.windows();
//     let parent_window = windows.values().next();
//     let package_info = app.package_info().clone();

//     let body = update.body().unwrap();
//     // todo(lemarier): We should review this and make sure we have
//     // something more conventional.
//     let should_install = tauri::api::dialog::blocking::ask(
//         parent_window,
//         format!(r#"A new version of {} is available! "#, package_info.name),
//         format!(
//             r#"{} {} is now available -- you have {}.

// Would you like to install it now?

// Release Notes:
// {}"#,
//             package_info.name,
//             update.latest_version(),
//             package_info.version,
//             body
//         ),
//     );

//     if should_install {
//         // Launch updater download process
//         // macOS we display the `Ready to restart dialog` asking to restart
//         // Windows is closing the current App and launch the downloaded MSI when ready (the process stop here)
//         // Linux we replace the AppImage by launching a new install, it start a new AppImage instance, so we're closing the previous. (the process stop here)
//         update.download_and_install().await?;

//         // Ask user if we need to restart the application
//         let should_exit = tauri::api::dialog::blocking::ask(
//             parent_window,
//             "Ready to Restart",
//             "The installation was successful, do you want to restart the application now?",
//         );
//         if should_exit {
//             app.restart();
//         }
//     }

//     Ok(())
// }

// #[command]
// pub async fn silent_install(app: AppHandle<Wry>, update: UpdateResponse<Wry>) -> Result<()> {
//     info!("silent_install");
//     let windows = app.windows();
//     let parent_window = windows.values().next();

//     // Launch updater download process
//     // macOS we display the `Ready to restart dialog` asking to restart
//     // Windows is closing the current App and launch the downloaded MSI when ready (the process stop here)
//     // Linux we replace the AppImage by launching a new install, it start a new AppImage instance, so we're closing the previous. (the process stop here)
//     update.download_and_install().await?;

//     // Ask user if we need to restart the application
//     let should_exit = tauri::api::dialog::blocking::ask(
//         parent_window,
//         "Ready to Restart",
//         "The silent installation was successful, do you want to restart the application now?",
//     );
//     if should_exit {
//         app.restart();
//     }

//     Ok(())
// }